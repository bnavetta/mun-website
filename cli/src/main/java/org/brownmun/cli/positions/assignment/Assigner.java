package org.brownmun.cli.positions.assignment;

import com.fasterxml.jackson.databind.MappingIterator;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.ObjectWriter;
import com.fasterxml.jackson.databind.SequenceWriter;
import com.fasterxml.jackson.dataformat.csv.CsvMapper;
import com.fasterxml.jackson.dataformat.csv.CsvSchema;
import com.google.common.collect.Comparators;
import com.google.common.collect.Lists;
import com.google.common.collect.Queues;
import org.brownmun.cli.positions.SchoolAllocation;
import org.brownmun.core.committee.CommitteeService;
import org.brownmun.core.committee.model.Committee;
import org.brownmun.core.committee.model.CommitteeType;
import org.brownmun.core.committee.model.Position;
import org.brownmun.core.school.SchoolService;
import org.brownmun.core.school.model.School;

import java.io.File;
import java.io.IOException;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Queue;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Manages the assignment of positions to schools. This is done in two steps. First,
 * {@link AssignmentSolver} is used to determine how many positions in each committee should go to
 * each school. Then, positions within each committee are randomly assigned to schools.
 */
public class Assigner
{
    private final ObjectMapper jsonMapper;
    private final CsvMapper csvMapper;
    private final CommitteeService committeeService;
    private final SchoolService schoolService;

    private final CsvSchema allocationSchema;
    private final CsvSchema assignmentSchema;

    public Assigner(ObjectMapper jsonMapper, CsvMapper csvMapper, CommitteeService committeeService, SchoolService schoolService)
    {
        this.jsonMapper = jsonMapper;
        this.csvMapper = csvMapper;
        this.committeeService = committeeService;
        this.schoolService = schoolService;
        this.allocationSchema = csvMapper.typedSchemaFor(SchoolAllocation.class).withHeader();
        this.assignmentSchema = csvMapper.typedSchemaFor(PositionAssignment.class).withHeader();
    }

    private AssignableCommittee toAssignable(Committee c)
    {
        return AssignableCommittee.create(c.getId(), committeeService.getPositions(c).size());
    }

    /**
     * Randomly assign positions to schools based on the assignments generated by the {@link AssignmentSolver}.
     * @param solver a solved solver to read assignments from
     * @param committees all committees assigned
     * @return a list of all position assignments
     */
    private List<PositionAssignment> makeAssignments(AssignmentSolver solver, List<AssignableCommittee> committees)
    {
        List<School> schools = schoolService.listSchools();

        List<PositionAssignment> assignments = Lists.newArrayList();

        for (AssignableCommittee aCommittee : committees)
        {
            Committee committee = committeeService.getCommittee(aCommittee.id())
                    .orElseThrow(() -> new IllegalArgumentException("Invalid committee ID: " + aCommittee.id()));

            // TODO: just use a linked list from the start?
            List<Position> positions = Lists.newArrayList(committeeService.getPositions(committee));
            // TODO: could prioritize based on importance, desirability, etc. (would need to change school iteration to be fair)
            Collections.shuffle(positions);
            Queue<Position> available = Queues.newArrayDeque(positions);

            for (School school : schools)
            {
                int assigned = solver.getDelegates(school.getId(), committee.getId());
                for (int i = 0; i < assigned; i++)
                {
                    assignments.add(PositionAssignment.builder()
                    .withCommittee(committee)
                    .withSchool(school)
                    .withPosition(available.remove())
                    .build());
                }
            }
        }

        return assignments;
    }

    /**
     * Assigns committees to positions.
     * @param settings parameters to the assignment algorithm
     * @param allocations the predefined school allocations
     * @return a list of all position assignments
     */
    public List<PositionAssignment> assign(AssignmentSettings settings, List<SchoolAllocation> allocations)
    {
        List<AssignableCommittee> ga = committeeService.allByType(CommitteeType.GENERAL)
                .map(this::toAssignable).collect(Collectors.toList());
        List<AssignableCommittee> spec = committeeService.allByType(CommitteeType.SPECIALIZED)
                .map(this::toAssignable).collect(Collectors.toList());

        List<AssignableCommittee> crisis = Stream.concat(
                committeeService.allByType(CommitteeType.CRISIS),
                committeeService.allByType(CommitteeType.JOINT_CRISIS_ROOM))
                .map(this::toAssignable).collect(Collectors.toList());

        long maxCommitteeId = Stream.concat(ga.stream(), Stream.concat(spec.stream(), crisis.stream()))
                .mapToLong(AssignableCommittee::id).max().getAsLong();
        long maxSchoolId = allocations.stream().mapToLong(SchoolAllocation::id).max().getAsLong();

        AssignmentSolver solver = new AssignmentSolver((int) maxSchoolId, (int) maxCommitteeId);
        boolean success = solver.solve(settings, allocations, ga, spec, crisis);
        if (!success)
        {
            // TODO: could automatically adjust GA overlap until it works
            throw new IllegalStateException("Could not solve assignment. Try increasing overlap");
        }

        List<AssignableCommittee> allCommittees = Lists.newArrayListWithExpectedSize(ga.size() + spec.size() + crisis.size());
        allCommittees.addAll(ga);
        allCommittees.addAll(spec);
        allCommittees.addAll(crisis);
        return makeAssignments(solver, allCommittees);
    }

    private List<SchoolAllocation> readAllocations(File source) throws IOException
    {
        try (MappingIterator<SchoolAllocation> allocationIter = csvMapper.readerFor(SchoolAllocation.class).with(allocationSchema).readValues(source))
        {
            return allocationIter.readAll();
        }
    }

    /**
     * Assign committees to positions based on pregenerated input files and write the output as CSV.
     * @param settingsFile file containing the JSON {@link AssignmentSettings}
     * @param allocationsFile CSV file containing {@link SchoolAllocation}s
     * @param assignmentsFile CSV file to write {@link PositionAssignment}s to
     * @return the generated position assignments
     */
    public List<PositionAssignment> assign(File settingsFile, File allocationsFile, File assignmentsFile) throws IOException
    {
        AssignmentSettings settings = jsonMapper.readValue(settingsFile, AssignmentSettings.class);
        List<SchoolAllocation> allocations = readAllocations(allocationsFile);

        List<PositionAssignment> assignments = assign(settings, allocations);

        assignments.sort(Comparator.comparing(PositionAssignment::schoolName).thenComparing(PositionAssignment::committeeName));

        ObjectWriter writer = csvMapper.writerFor(PositionAssignment.class).with(assignmentSchema);
        try (SequenceWriter out = writer.writeValues(assignmentsFile))
        {
            out.writeAll(assignments);
        }

        return assignments;
    }
}
