package org.brownmun.cli.positions.assignment;

import java.io.File;
import java.io.IOException;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Queue;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.transaction.support.TransactionTemplate;

import com.fasterxml.jackson.databind.MappingIterator;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.ObjectWriter;
import com.fasterxml.jackson.databind.SequenceWriter;
import com.fasterxml.jackson.dataformat.csv.CsvMapper;
import com.fasterxml.jackson.dataformat.csv.CsvSchema;
import com.google.common.collect.Lists;
import com.google.common.collect.Queues;

import org.brownmun.cli.positions.SchoolAllocation;
import org.brownmun.core.committee.CommitteeService;
import org.brownmun.core.committee.model.Committee;
import org.brownmun.core.committee.model.CommitteeType;
import org.brownmun.core.committee.model.Position;
import org.brownmun.core.school.SchoolService;
import org.brownmun.core.school.model.School;

/**
 * Manages the assignment of positions to schools. This is done in two steps.
 * First, {@link AssignmentSolver} is used to determine how many positions in
 * each committee should go to each school. Then, positions within each
 * committee are randomly assigned to schools.
 */
public class Assigner {
    private static final Logger log = LoggerFactory.getLogger(Assigner.class);

    private final ObjectMapper jsonMapper;
    private final CsvMapper csvMapper;
    private final CommitteeService committeeService;
    private final SchoolService schoolService;
    private final TransactionTemplate tx;

    private final CsvSchema allocationSchema;
    private final CsvSchema assignmentSchema;

    public Assigner(ObjectMapper jsonMapper, CsvMapper csvMapper, CommitteeService committeeService,
            SchoolService schoolService, TransactionTemplate tx) {
        this.jsonMapper = jsonMapper;
        this.csvMapper = csvMapper;
        this.committeeService = committeeService;
        this.schoolService = schoolService;
        this.allocationSchema = csvMapper.typedSchemaFor(SchoolAllocation.class).withHeader();
        this.assignmentSchema = csvMapper.typedSchemaFor(PositionAssignment.class).withHeader();
        this.tx = tx;
    }

    private AssignableCommittee toAssignable(Committee c, AssignmentSettings settings) {
        long capacity = committeeService.getPositions(c).stream()
                .filter(p -> !settings.reservedPositions().contains(p.getId())).count();
        return AssignableCommittee.create(c.getId(), Math.toIntExact(capacity));
    }

    /**
     * Randomly assign positions to schools based on the assignments generated by
     * the {@link AssignmentSolver}.
     *
     * @param solver     a solved solver to read assignments from
     * @param committees all committees assigned
     * @return a list of all position assignments
     */
    private List<PositionAssignment> makeAssignments(List<SchoolAllocation> schools, AssignmentSettings settings,
            AssignmentSolver solver, List<AssignableCommittee> committees) {
        List<PositionAssignment> assignments = Lists.newArrayList();

        for (AssignableCommittee aCommittee : committees) {
            Committee committee = committeeService.getCommittee(aCommittee.id())
                    .orElseThrow(() -> new IllegalArgumentException("Invalid committee ID: " + aCommittee.id()));

            // TODO: just use a linked list from the start?
            List<Position> positions = committeeService.getPositions(committee).stream()
                    .filter(p -> !settings.reservedPositions().contains(p.getId())).collect(Collectors.toList());
            // TODO: could prioritize based on importance, desirability, etc. (would need to
            // change school iteration to be fair)
            Collections.shuffle(positions);
            Queue<Position> available = Queues.newArrayDeque(positions);

            for (SchoolAllocation school : schools) {
                int assigned = solver.getDelegates(school.id(), committee.getId());
                // log.debug("assigned {}", assigned);
                for (int i = 0; i < assigned; i++) {
                    School s = schoolService.getSchool(school.id()).get();
                    log.debug("available size {}", available.size());
                    if (available.isEmpty()) {
                        continue;
                    }
                    Position position = available.remove();
                    log.debug("Assigning {} in {} to {} ({} positions left)", position.getName(), committee.getName(),
                            s.getName(), available.size());
                    assignments.add(PositionAssignment.builder().withCommittee(committee).withSchool(s)
                            .withPosition(position).build());
                }
            }
        }

        return assignments;
    }

    /**
     * Assigns committees to positions.
     *
     * @param settings    parameters to the assignment algorithm
     * @param allocations the predefined school allocations
     * @return a list of all position assignments
     */
    @Transactional(readOnly = true)
    public List<PositionAssignment> assign(AssignmentSettings settings, List<SchoolAllocation> allocations) {
        List<AssignableCommittee> ga = tx.execute(t -> {
            try (Stream<Committee> cs = committeeService.allByType(CommitteeType.GENERAL)) {
                return cs.map(c -> toAssignable(c, settings)).collect(Collectors.toList());
            }
        });

        List<AssignableCommittee> spec = tx.execute(t -> {
            try (Stream<Committee> cs = committeeService.allByType(CommitteeType.SPECIALIZED)) {
                return cs.map(c -> toAssignable(c, settings)).collect(Collectors.toList());
            }
        });

        List<AssignableCommittee> crisis = tx.execute(t -> {
            try (Stream<Committee> cs = committeeService.allByType(CommitteeType.CRISIS);
                    Stream<Committee> jcs = committeeService.allByType(CommitteeType.JOINT_CRISIS)) {
                // Stream<Committee> jcs =
                // committeeService.allByType(CommitteeType.JOINT_CRISIS_ROOM)) {
                return Stream.concat(cs, jcs).map(c -> toAssignable(c, settings)).collect(Collectors.toList());
            }
        });

        long maxCommitteeId = Stream.concat(ga.stream(), Stream.concat(spec.stream(), crisis.stream()))
                .mapToLong(AssignableCommittee::id).max().getAsLong();
        long maxSchoolId = allocations.stream().mapToLong(SchoolAllocation::id).max().getAsLong();

        AssignmentSolver solver = new AssignmentSolver((int) maxSchoolId, (int) maxCommitteeId);
        boolean success = solver.solve(settings, allocations, ga, spec, crisis);
        // if (!success) {
        // // TODO: could automatically adjust GA overlap until it works
        // throw new IllegalStateException("Could not solve assignment. Try increasing
        // overlap");
        // }

        List<AssignableCommittee> allCommittees = Lists
                .newArrayListWithExpectedSize(ga.size() + spec.size() + crisis.size());
        allCommittees.addAll(ga);
        allCommittees.addAll(spec);
        allCommittees.addAll(crisis);
        return makeAssignments(allocations, settings, solver, allCommittees);
    }

    private List<SchoolAllocation> readAllocations(File source) throws IOException {
        try (MappingIterator<SchoolAllocation> allocationIter = csvMapper.readerFor(SchoolAllocation.class)
                .with(allocationSchema).readValues(source)) {
            return allocationIter.readAll();
        }
    }

    /**
     * Assign committees to positions based on pregenerated input files and write
     * the output as CSV.
     *
     * @param settingsFile    file containing the JSON {@link AssignmentSettings}
     * @param allocationsFile CSV file containing {@link SchoolAllocation}s
     * @param assignmentsFile CSV file to write {@link PositionAssignment}s to
     * @return the generated position assignments
     */
    public List<PositionAssignment> assign(File settingsFile, File allocationsFile, File assignmentsFile)
            throws IOException {
        AssignmentSettings settings = jsonMapper.readValue(settingsFile, AssignmentSettings.class);
        List<SchoolAllocation> allocations = readAllocations(allocationsFile);

        List<PositionAssignment> assignments = assign(settings, allocations);

        assignments.sort(
                Comparator.comparing(PositionAssignment::schoolName).thenComparing(PositionAssignment::committeeName));

        ObjectWriter writer = csvMapper.writerFor(PositionAssignment.class).with(assignmentSchema);
        try (SequenceWriter out = writer.writeValues(assignmentsFile)) {
            out.writeAll(assignments);
        }

        return assignments;
    }
}
