#!/usr/bin/env python
import json
import os
import subprocess

import click
import paramiko
from sshtunnel import SSHTunnelForwarder


def ssh_client():
    client = paramiko.SSHClient()
    client.load_system_host_keys()
    client.connect('busun.org', username='brownmun')
    return client


def tunnel(target_address, target_port):
    return SSHTunnelForwarder(
        'busun.org',
        ssh_username='brownmun',
        remote_bind_address=(target_address, target_port),
    )


def container_ip(container_name):
    """
    Get the bridge network IP address of a container. Since our Docker containers run on a user-defined bridge
    network, we need to look up their IP address to connect to them from the host server
    """
    client = ssh_client()
    _, stdout, _ = client.exec_command('docker inspect -f \'{{ (index .NetworkSettings.Networks "mun-net").IPAddress }}\' ' + container_name)
    ip = stdout.read().strip()
    client.close()
    return ip.decode('utf-8')


def run_shell(extra_args, env):
    """Runs the command-line shell application"""
    subprocess.check_call(['./gradlew', '--console', 'plain', '-q', '-PstableVersion', 'cli:bootJar'])
    # Make sure the CLI runs with direct terminal access and the correct (non-daemon) environment variables
    subprocess.call([
        'java', '-Djava.library.path=cli/or-tools/lib', '-jar', 'cli/build/libs/cli-latest.jar',
        '--conference.name=BUSUN', '--conference.key=busun', '--conference.domainName=busun.org'
    ] + list(extra_args), env=env)


def version():
    """Gets the current project version from Gradle"""
    output = subprocess.check_output(['./gradlew', '--console', 'plain', '-q', 'printVersion'])
    return output.decode(encoding='utf-8').strip()

@click.group(context_settings=dict(help_option_names=['-h', '--help']))
def cli():
    pass


@cli.group()
def dev():
    pass


@dev.command()
def startdb():
    click.secho('Starting local database...', fg='green')
    subprocess.call(['docker-compose', 'up', '-d', 'database', 'adminer'])


@dev.command()
def stopdb():
    click.secho('Stopping local database...', fg='green')
    subprocess.call(['docker-compose', 'stop', 'database', 'adminer'])


@dev.command()
def querydb():
    subprocess.call(['docker-compose', 'exec', 'database', 'psql', '-U', os.environ['DB_USER']])


@dev.command()
@click.option('--debug/--no-debug', default=False)
def run(debug):
    subprocess.call(['./gradlew', '-PstableVersion', 'busun:bootJar'])
    args = ['java']
    if debug:
        args.append('-agentlib:jdwp=transport=dt_socket,address=localhost:5005,server=y,suspend=y')
    args.extend(('-jar', 'busun/build/libs/busun-latest.jar'))
    if debug:
        args.append('--debug')
    subprocess.call(args)


@dev.command('shell', context_settings=dict(ignore_unknown_options=True))
@click.argument('extra_args', nargs=-1, type=click.UNPROCESSED)
def dev_shell(extra_args):
    run_shell(extra_args, os.environ)


@cli.group()
def prod():
    pass


@prod.command('querydb')
def prod_querydb():
    with tunnel(container_ip('postgres'), 5432) as t:
        env = dict(os.environ)
        env['PGPASSWORD'] = env['PROD_DB_PASSWORD']
        subprocess.call(['psql', '-h', 'localhost', '-p', str(t.local_bind_port), '-U', 'postgres', 'busun'], env=env)


@prod.command('shell', context_settings=dict(ignore_unknown_options=True))
@click.argument('extra_args', nargs=-1, type=click.UNPROCESSED)
def prod_shell(extra_args):
    with tunnel(container_ip('postgres'), 5432) as t:
        env = dict(os.environ)
        env['DB_USER'] = 'postgres'
        env['DB_PASSWORD'] = env['PROD_DB_PASSWORD']
        env['DB_JDBC_URL'] = 'jdbc:postgresql://localhost:{}/busun'.format(t.local_bind_port)
        run_shell(extra_args, env)


@prod.command('ssh')
def prod_ssh():
    subprocess.call(['ssh', '-i', 'provisioning/keys/id_rsa', 'brownmun@busun.org'])


@prod.command('dumpdb')
@click.argument('out', required=False)
def prod_dump_db(out):
    with tunnel(container_ip('postgres'), 5432) as t:
        env = dict(os.environ)
        env['PGPASSWORD'] = env['PROD_DB_PASSWORD']
        args = ['pg_dump', '-h', 'localhost', '-p', str(t.local_bind_port), '-U', 'postgres', 'busun']
        if out:
            args.extend(['-f', out])
        subprocess.call(args, env=env)

@cli.group(invoke_without_command=True, chain=True)
@click.pass_context
def fmt(ctx):
    if ctx.invoked_subcommand is None:
        click.secho('Formatting all files...', fg='green')
        ctx.invoke(prettier)
        ctx.invoke(eslint)
        ctx.invoke(stylelint)
        ctx.invoke(spotless)


@fmt.command()
def prettier():
    subprocess.call(['./node_modules/.bin/prettier', '--write', 'ui/**/*.{js,jsx,css}'])


@fmt.command()
def eslint():
    subprocess.call(['./node_modules/.bin/eslint', '--ext', '.js', '--ext', '.jsx', 'ui'])


@fmt.command()
def stylelint():
    subprocess.call(['./node_modules/.bin/stylelint', 'ui/src/**/*.css'])


@fmt.command()
def spotless():
    subprocess.call(['./gradlew', 'spotlessApply'])


@cli.command()
def deploy():
    ver = version()
    click.secho("Will deploy version {}".format(ver), fg='green')

    click.secho("Building Docker images", fg="green")
    subprocess.check_call(['./gradlew', 'pushImages'])

    # Pull over SSH - for some reason doing it through Ansible or Systemd fails
    client = ssh_client()
    client.exec_command('docker pull gcr.io/busun-158105/busun:' + ver)
    client.exec_command('docker pull gcr.io/busun-158105/ui:' + ver)
    client.close()

    click.secho("Running Ansible deploy playbook for BUSUN", fg="green")
    subprocess.check_call(
        ['ansible-playbook', 'deploy-conference.yml', '-e', 'conference=busun tag={}'.format(ver)],
        cwd='provisioning'
    )
    # TODO: BUCS and asset server


@cli.command()
@click.option('--ver', help='Version to keep', required=False)
def clean_images(ver):
    if not ver:
        ver = version()
    for image in ["gcr.io/busun-158105/busun", "gcr.io/busun-158105/ui"]:
        tags = json.loads(subprocess.check_output(["gcloud", "container", "images", "list-tags", image, "--format", "json"]))
        for tag in tags:
            if ver not in tag["tags"]:
                for tag in tag["tags"]:
                    click.secho("Deleting {}:{}".format(image, tag), fg="red")
                    subprocess.check_call([
                        "gcloud", "container", "images", "delete", "{}:{}".format(image, tag), "--force-delete-tags"
                    ])

if __name__ == '__main__':
    root = os.path.join(os.path.dirname(os.path.abspath(__file__)), '..')
    os.chdir(root)
    cli()
